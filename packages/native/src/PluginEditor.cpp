#include "PluginEditor.h"

namespace rau
{

    PluginEditor::PluginEditor(PluginProcessor &p)
        : AudioProcessorEditor(p), processor(p)
    {
        setSize(RAU_UI_WIDTH, RAU_UI_HEIGHT);

        // Get bridge-configured options (includes JS→C++ native function)
        auto options = processor.getWebViewBridge().createWebViewOptions();

#if RAU_EMBEDDED_UI
        // In production, serve the embedded UI via a resource provider.
        // BinaryData is generated by juce_add_binary_data in CMakeLists.txt.
        options = options.withResourceProvider(
            [](const juce::String &url) -> std::optional<juce::WebBrowserComponent::Resource>
            {
                // Map URL path to BinaryData resource name
                auto path = url.fromFirstOccurrenceOf("/", false, false);
                if (path.isEmpty() || path == "/")
                    path = "index.html";

                // Convert path to BinaryData name: replace / and . with _
                auto resourceName = path.replace("/", "_").replace(".", "_").replace("-", "_");

                for (int i = 0; i < BinaryData::namedResourceListSize; ++i)
                {
                    if (juce::String(BinaryData::namedResourceList[i]) == resourceName)
                    {
                        int size = 0;
                        auto *data = BinaryData::getNamedResource(
                            BinaryData::namedResourceList[i], size);
                        if (data != nullptr)
                        {
                            // Determine MIME type from extension
                            juce::String mime = "application/octet-stream";
                            if (path.endsWith(".html"))
                                mime = "text/html";
                            else if (path.endsWith(".js"))
                                mime = "application/javascript";
                            else if (path.endsWith(".css"))
                                mime = "text/css";
                            else if (path.endsWith(".json"))
                                mime = "application/json";
                            else if (path.endsWith(".svg"))
                                mime = "image/svg+xml";
                            else if (path.endsWith(".png"))
                                mime = "image/png";
                            else if (path.endsWith(".woff2"))
                                mime = "font/woff2";

                            std::vector<std::byte> bytes(
                                reinterpret_cast<const std::byte *>(data),
                                reinterpret_cast<const std::byte *>(data) + size);

                            return juce::WebBrowserComponent::Resource{
                                std::move(bytes), mime.toStdString()};
                        }
                    }
                }

                return std::nullopt;
            });
#endif

        webView = std::make_unique<juce::WebBrowserComponent>(options);
        addAndMakeVisible(*webView);

        // Tell the bridge about our WebView so it can send C++→JS messages
        processor.getWebViewBridge().setWebView(webView.get());

// Navigate to the appropriate URL
#if RAU_EMBEDDED_UI
        webView->goToURL(juce::WebBrowserComponent::getResourceProviderRoot());
#else
        // Development mode: connect to Vite dev server
        webView->goToURL("http://localhost:5173");
#endif
    }

    PluginEditor::~PluginEditor()
    {
        // Disconnect the bridge before the WebView is destroyed
        processor.getWebViewBridge().setWebView(nullptr);
    }

    void PluginEditor::resized()
    {
        if (webView)
        {
            webView->setBounds(getLocalBounds());
        }
    }

} // namespace rau
